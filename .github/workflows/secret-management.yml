name: 🔐 Secret Management & Security

on:
  push:
    branches: [ main, develop ]
    paths:
      - '**/*.json'
      - '**/*.py'
      - '**/*.js'
      - '**/*.ts'
      - '**/*.env*'
      - '**/*.yml'
      - '**/*.yaml'
      - 'scripts/**'
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run daily secret scan at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'scan'
        type: choice
        options:
          - scan
          - replace
          - sync-secrets
          - generate-configs

env:
  SECRET_SCAN_PATTERNS: |
    sk-[a-zA-Z0-9]{20,}
    xoxb-[0-9]+-[0-9]+-[0-9]+-[a-zA-Z0-9]+
    ghp_[A-Za-z0-9]{36}
    gho_[A-Za-z0-9]{36}
    ghu_[A-Za-z0-9]{36}
    ghs_[A-Za-z0-9]{36}
    ghr_[A-Za-z0-9]{36}
    AIza[0-9A-Za-z-_]{35}
    AKIA[0-9A-Z]{16}
    [a-zA-Z0-9+/]{40}

jobs:
  # Job 1: Scan for hardcoded secrets
  secret-scan:
    name: 🔍 Secret Detection Scan
    runs-on: ubuntu-latest
    outputs:
      secrets-found: ${{ steps.scan.outputs.secrets-found }}
      scan-results: ${{ steps.scan.outputs.scan-results }}
    
    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: 📦 Install dependencies
      run: |
        pip install --upgrade pip
        pip install pyyaml requests python-dotenv gitpython

    - name: 🔍 Scan for hardcoded secrets
      id: scan
      run: |
        python3 -c "
        import re
        import os
        import json
        import glob
        from pathlib import Path

        # Secret patterns to detect
        patterns = {
            'openai': r'sk-[a-zA-Z0-9]{48,}',
            'github': r'gh[pousr]_[A-Za-z0-9]{36}',
            'slack': r'xoxb-[0-9]+-[0-9]+-[0-9]+-[a-zA-Z0-9]+',
            'google': r'AIza[0-9A-Za-z\\-_]{35}',
            'aws': r'AKIA[0-9A-Z]{16}',
            'generic_key': r'['\''\"](api_key|apikey|secret_key|password)['\''\"]\s*[:=]\s*['\''\"'][^'\''\"\s]{20,}['\''\"']',
            'json_key': r'\"(apiKey|api_key|secretKey|secret_key|password|token)\":\s*\"[^\"]{20,}\"'
        }

        found_secrets = []
        exclude_dirs = {'.git', 'node_modules', '__pycache__', '.venv', 'venv', 'build', 'dist'}
        
        def scan_file(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    
                for secret_type, pattern in patterns.items():
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        line_num = content[:match.start()].count('\n') + 1
                        found_secrets.append({
                            'file': str(filepath),
                            'line': line_num,
                            'type': secret_type,
                            'match': match.group()[:50] + '...' if len(match.group()) > 50 else match.group()
                        })
            except Exception as e:
                print(f'Error scanning {filepath}: {e}')

        # Scan all relevant files
        file_patterns = ['**/*.py', '**/*.js', '**/*.ts', '**/*.json', '**/*.yml', '**/*.yaml', '**/*.env*']
        
        for pattern in file_patterns:
            for filepath in Path('.').glob(pattern):
                if any(exc_dir in str(filepath) for exc_dir in exclude_dirs):
                    continue
                if filepath.is_file():
                    scan_file(filepath)

        # Output results
        secrets_found = len(found_secrets) > 0
        print(f'::set-output name=secrets-found::{str(secrets_found).lower()}')
        
        if found_secrets:
            results_json = json.dumps(found_secrets, indent=2)
            print(f'::set-output name=scan-results::{results_json}')
            
            print('🚨 SECRETS DETECTED:')
            for secret in found_secrets:
                print(f\"  {secret['file']}:{secret['line']} - {secret['type']} - {secret['match']}\")
        else:
            print('✅ No hardcoded secrets detected')
        "

    - name: 📊 Upload scan results
      if: steps.scan.outputs.secrets-found == 'true'
      uses: actions/upload-artifact@v3
      with:
        name: secret-scan-results
        path: |
          secret-scan-results.json
        retention-days: 30

    - name: ⚠️ Fail on secrets found
      if: steps.scan.outputs.secrets-found == 'true' && github.event_name == 'pull_request'
      run: |
        echo "❌ Hardcoded secrets detected! Please use GitHub secrets instead."
        echo "${{ steps.scan.outputs.scan-results }}"
        exit 1

  # Job 2: Auto-replace hardcoded secrets with environment variables
  secret-replacement:
    name: 🔄 Auto-Replace Secrets
    runs-on: ubuntu-latest
    needs: secret-scan
    if: github.event.inputs.action == 'replace' || (needs.secret-scan.outputs.secrets-found == 'true' && github.ref == 'refs/heads/main')
    
    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: 🔄 Replace hardcoded secrets
      run: |
        python3 - <<'EOF'
        import re
        import os
        import json
        from pathlib import Path

        # Replacement patterns
        replacements = {
            r'\"apiKey\":\s*\"sk-[^\"]+\"': '\"apiKey\": \"${OPENAI_API_KEY}\"',
            r'\"APIKey\":\s*\"sk-[^\"]+\"': '\"APIKey\": \"${OPENAI_API_KEY}\"',
            r'\"api_key\":\s*\"sk-[^\"]+\"': '\"api_key\": \"${OPENAI_API_KEY}\"',
            r'sk-[a-zA-Z0-9]{48,}': '${OPENAI_API_KEY}',
            r'\"token\":\s*\"gh[pousr]_[^\"]+\"': '\"token\": \"${GH_TOKEN}\"',
            r'gh[pousr]_[A-Za-z0-9]{36}': '${GH_TOKEN}',
            r'\"apiKey\":\s*\"AIza[^\"]+\"': '\"apiKey\": \"${GOOGLE_API_KEY}\"',
            r'AIza[0-9A-Za-z\\-_]{35}': '${GOOGLE_API_KEY}',
            r'\"password\":\s*\"[^\"]{8,}\"': '\"password\": \"${DATABASE_PASSWORD}\"',
        }

        exclude_dirs = {'.git', 'node_modules', '__pycache__', '.venv', 'venv', 'build', 'dist'}
        files_modified = []

        def replace_in_file(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                original_content = content
                for pattern, replacement in replacements.items():
                    content = re.sub(pattern, replacement, content, flags=re.IGNORECASE)
                
                if content != original_content:
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(content)
                    files_modified.append(str(filepath))
                    print(f'✅ Updated: {filepath}')
                    
            except Exception as e:
                print(f'❌ Error processing {filepath}: {e}')

        # Process all relevant files
        file_patterns = ['**/*.py', '**/*.js', '**/*.ts', '**/*.json', '**/*.yml', '**/*.yaml']
        
        for pattern in file_patterns:
            for filepath in Path('.').glob(pattern):
                if any(exc_dir in str(filepath) for exc_dir in exclude_dirs):
                    continue
                if filepath.is_file():
                    replace_in_file(filepath)

        print(f'📊 Modified {len(files_modified)} files')
        
        # Set output for next step
        with open('modified_files.txt', 'w') as f:
            for file in files_modified:
                f.write(f'{file}\n')
        EOF

    - name: 📝 Commit changes
      run: |
        if [ -f modified_files.txt ] && [ -s modified_files.txt ]; then
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action - Secret Management"
          git add -A
          git commit -m "🔐 Auto-replace hardcoded secrets with environment variables

          - Replaced hardcoded API keys with environment variable references
          - Updated $(wc -l < modified_files.txt) files
          - Improved security posture

          🤖 Generated by GitHub Actions Secret Management"
          git push
        else
          echo "No files were modified"
        fi

  # Job 3: Sync secrets to environment files
  sync-secrets:
    name: 🔄 Sync Repository Secrets
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'sync-secrets' || github.ref == 'refs/heads/main'
    
    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4

    - name: 🔐 Generate environment files from secrets
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        LANGCHAIN_API_KEY: ${{ secrets.LANGCHAIN_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD }}
        NEO4J_USERNAME: ${{ secrets.NEO4J_USERNAME }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        RABBITMQ_PASSWORD: ${{ secrets.RABBITMQ_PASSWORD }}
        RABBITMQ_USER: ${{ secrets.RABBITMQ_USER }}
        OPENWEBUI_SECRET_KEY: ${{ secrets.OPENWEBUI_SECRET_KEY }}
        VSCODE_PASSWORD: ${{ secrets.VSCODE_PASSWORD }}
      run: |
        # Create production environment file
        cat > .env.production << EOF
        # Production Environment Configuration
        # Generated from GitHub Secrets on $(date)
        
        # AI Service API Keys
        OPENAI_API_KEY=$OPENAI_API_KEY
        ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
        AZURE_OPENAI_KEY=$AZURE_OPENAI_KEY
        GEMINI_API_KEY=$GEMINI_API_KEY
        GOOGLE_API_KEY=$GOOGLE_API_KEY
        LANGCHAIN_API_KEY=$LANGCHAIN_API_KEY
        
        # Database Credentials
        NEO4J_PASSWORD=$NEO4J_PASSWORD
        NEO4J_USERNAME=$NEO4J_USERNAME
        POSTGRES_PASSWORD=$POSTGRES_PASSWORD
        
        # Message Queue
        RABBITMQ_PASSWORD=$RABBITMQ_PASSWORD
        RABBITMQ_USER=$RABBITMQ_USER
        
        # Application Secrets
        OPENWEBUI_SECRET_KEY=$OPENWEBUI_SECRET_KEY
        VSCODE_PASSWORD=$VSCODE_PASSWORD
        
        # GitHub Integration
        GH_TOKEN=$GH_TOKEN
        EOF
        
        # Create development template
        cat > .env.development.template << EOF
        # Development Environment Template
        # Copy to .env.development and fill in your development keys
        
        # AI Service API Keys (get your own for development)
        OPENAI_API_KEY=your_openai_key_here
        ANTHROPIC_API_KEY=your_anthropic_key_here
        AZURE_OPENAI_KEY=your_azure_openai_key_here
        GEMINI_API_KEY=your_gemini_key_here
        GOOGLE_API_KEY=your_google_key_here
        LANGCHAIN_API_KEY=your_langchain_key_here
        
        # Database Credentials (development defaults)
        NEO4J_PASSWORD=development_password
        NEO4J_USERNAME=neo4j
        POSTGRES_PASSWORD=development_password
        
        # Message Queue (development defaults)
        RABBITMQ_PASSWORD=development_password
        RABBITMQ_USER=development_user
        
        # Application Secrets (development defaults)
        OPENWEBUI_SECRET_KEY=development_secret_key
        VSCODE_PASSWORD=development_password
        
        # GitHub Integration (personal access token)
        GITHUB_TOKEN=your_github_token_here
        EOF

    - name: 📊 Update secret inventory
      run: |
        python3 - <<'EOF'
        import json
        import os
        from datetime import datetime

        # Current secrets inventory
        secrets_inventory = {
            "last_updated": datetime.now().isoformat(),
            "secrets_managed": [
                {
                    "name": "OPENAI_API_KEY",
                    "description": "OpenAI API key for GPT models",
                    "required_for": ["webapi", "python/ai-stack", "genai-stack"],
                    "type": "api_key"
                },
                {
                    "name": "ANTHROPIC_API_KEY", 
                    "description": "Anthropic API key for Claude models",
                    "required_for": ["python/ai-stack"],
                    "type": "api_key"
                },
                {
                    "name": "AZURE_OPENAI_KEY",
                    "description": "Azure OpenAI service key",
                    "required_for": ["webapi", "memorypipeline"],
                    "type": "api_key"
                },
                {
                    "name": "GEMINI_API_KEY",
                    "description": "Google Gemini API key",
                    "required_for": ["python/ai-stack"],
                    "type": "api_key"
                },
                {
                    "name": "GOOGLE_API_KEY",
                    "description": "Google Cloud API key",
                    "required_for": ["python/ai-stack"],
                    "type": "api_key"
                },
                {
                    "name": "LANGCHAIN_API_KEY",
                    "description": "LangChain API key",
                    "required_for": ["python/ai-stack", "genai-stack"],
                    "type": "api_key"
                },
                {
                    "name": "NEO4J_PASSWORD",
                    "description": "Neo4j database password",
                    "required_for": ["genai-stack", "docker-compose"],
                    "type": "password"
                },
                {
                    "name": "NEO4J_USERNAME",
                    "description": "Neo4j database username",
                    "required_for": ["genai-stack", "docker-compose"],
                    "type": "username"
                },
                {
                    "name": "POSTGRES_PASSWORD",
                    "description": "PostgreSQL database password",
                    "required_for": ["docker-compose", "webapi"],
                    "type": "password"
                },
                {
                    "name": "RABBITMQ_PASSWORD",
                    "description": "RabbitMQ message broker password",
                    "required_for": ["docker-compose", "memorypipeline"],
                    "type": "password"
                },
                {
                    "name": "RABBITMQ_USER",
                    "description": "RabbitMQ message broker username",
                    "required_for": ["docker-compose", "memorypipeline"],
                    "type": "username"
                },
                {
                    "name": "OPENWEBUI_SECRET_KEY",
                    "description": "Open WebUI secret key",
                    "required_for": ["docker-compose"],
                    "type": "secret_key"
                },
                {
                    "name": "VSCODE_PASSWORD",
                    "description": "VS Code server password",
                    "required_for": ["docker-compose"],
                    "type": "password"
                },
                {
                    "name": "GITHUB_TOKEN",
                    "description": "GitHub personal access token",
                    "required_for": ["github-actions", "python/ai-stack"],
                    "type": "token"
                }
            ],
            "total_secrets": 14,
            "security_notes": [
                "All secrets should be stored in GitHub Secrets",
                "Never commit actual secret values to the repository",
                "Use environment variable references in configuration files",
                "Rotate secrets regularly for security"
            ]
        }

        with open('secrets-inventory.json', 'w') as f:
            json.dump(secrets_inventory, f, indent=2)

        print("✅ Secrets inventory updated")
        EOF

    - name: 📤 Upload generated files
      uses: actions/upload-artifact@v3
      with:
        name: environment-configs
        path: |
          .env.production
          .env.development.template
          secrets-inventory.json
        retention-days: 7

  # Job 4: Generate configuration files
  generate-configs:
    name: 📝 Generate Configuration Templates
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'generate-configs' || github.ref == 'refs/heads/main'
    
    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4

    - name: 🔧 Generate configuration templates
      run: |
        # Update appsettings.json template
        python3 - <<'EOF'
        import json
        import re

        # Read current appsettings.json
        with open('webapi/appsettings.json', 'r') as f:
            config = json.load(f)

        # Replace hardcoded values with environment variables
        def replace_secrets_recursive(obj):
            if isinstance(obj, dict):
                for key, value in obj.items():
                    if isinstance(value, str):
                        # Replace API keys
                        if 'apikey' in key.lower() or 'api_key' in key.lower():
                            if 'openai' in str(value).lower() or value.startswith('sk-'):
                                obj[key] = '${OPENAI_API_KEY}'
                            elif 'azure' in key.lower():
                                obj[key] = '${AZURE_OPENAI_KEY}'
                            elif 'anthropic' in key.lower():
                                obj[key] = '${ANTHROPIC_API_KEY}'
                            elif 'gemini' in key.lower() or 'google' in key.lower():
                                obj[key] = '${GOOGLE_API_KEY}'
                        
                        # Replace passwords
                        elif 'password' in key.lower():
                            if 'neo4j' in key.lower():
                                obj[key] = '${NEO4J_PASSWORD}'
                            elif 'postgres' in key.lower():
                                obj[key] = '${POSTGRES_PASSWORD}'
                            elif 'rabbit' in key.lower():
                                obj[key] = '${RABBITMQ_PASSWORD}'
                        
                        # Replace usernames
                        elif 'username' in key.lower() or 'user' in key.lower():
                            if 'neo4j' in key.lower():
                                obj[key] = '${NEO4J_USERNAME}'
                            elif 'rabbit' in key.lower():
                                obj[key] = '${RABBITMQ_USER}'
                    else:
                        replace_secrets_recursive(value)
            elif isinstance(obj, list):
                for item in obj:
                    replace_secrets_recursive(item)

        # Apply replacements
        replace_secrets_recursive(config)

        # Write updated configuration
        with open('webapi/appsettings.template.json', 'w') as f:
            json.dump(config, f, indent=2)

        print("✅ Generated appsettings.template.json")
        EOF

        # Generate Docker Compose template
        sed 's/password: [^#]*/password: ${DATABASE_PASSWORD}/g' docker-compose.ai-stack.yml > docker-compose.template.yml
        sed -i 's/NEO4J_AUTH=neo4j\/[^#]*/NEO4J_AUTH=neo4j\/${NEO4J_PASSWORD}/g' docker-compose.template.yml

        echo "✅ Generated docker-compose.template.yml"

    - name: 📋 Create secret management README
      run: |
        cat > SECRET_MANAGEMENT.md << 'EOF'
        # 🔐 Secret Management Guide

        This repository uses GitHub Secrets for secure API key and credential management.

        ## 🎯 Managed Secrets

        | Secret Name | Description | Required For |
        |-------------|-------------|--------------|
        | `OPENAI_API_KEY` | OpenAI API key for GPT models | webapi, ai-stack |
        | `ANTHROPIC_API_KEY` | Anthropic API key for Claude | ai-stack |
        | `AZURE_OPENAI_KEY` | Azure OpenAI service key | webapi, memorypipeline |
        | `GEMINI_API_KEY` | Google Gemini API key | ai-stack |
        | `GOOGLE_API_KEY` | Google Cloud API key | ai-stack |
        | `LANGCHAIN_API_KEY` | LangChain API key | ai-stack, genai-stack |
        | `NEO4J_PASSWORD` | Neo4j database password | genai-stack, docker |
        | `NEO4J_USERNAME` | Neo4j database username | genai-stack, docker |
        | `POSTGRES_PASSWORD` | PostgreSQL password | docker, webapi |
        | `RABBITMQ_PASSWORD` | RabbitMQ password | docker, memorypipeline |
        | `RABBITMQ_USER` | RabbitMQ username | docker, memorypipeline |
        | `OPENWEBUI_SECRET_KEY` | Open WebUI secret | docker |
        | `VSCODE_PASSWORD` | VS Code server password | docker |
        | `GITHUB_TOKEN` | GitHub API token | actions, integrations |

        ## 🚀 Usage

        ### 1. GitHub Actions (Automatic)
        Secrets are automatically injected into workflows:
        ```yaml
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ```

        ### 2. Local Development
        Copy the development template:
        ```bash
        cp .env.development.template .env.development
        # Edit .env.development with your keys
        ```

        ### 3. Production Deployment
        Use the generated `.env.production` file or inject secrets directly.

        ## 🔧 GitHub Actions Workflows

        | Workflow | Purpose | Trigger |
        |----------|---------|---------|
        | **Secret Scan** | Detect hardcoded secrets | Push, PR, Daily |
        | **Auto-Replace** | Replace hardcoded secrets | Manual, Found secrets |
        | **Sync Secrets** | Generate environment files | Push to main |
        | **Generate Configs** | Create configuration templates | Manual |

        ## 🛡️ Security Best Practices

        1. **Never commit actual secret values**
        2. **Use environment variable references**: `${SECRET_NAME}`
        3. **Rotate secrets regularly**
        4. **Use different secrets for different environments**
        5. **Monitor for secret leaks with automated scans**

        ## 🔄 Managing Secrets

        ### Adding a New Secret
        1. Add to GitHub repository secrets
        2. Update `secrets-inventory.json`
        3. Add to environment templates
        4. Update configuration files to use `${SECRET_NAME}`

        ### Rotating Secrets
        1. Generate new secret value
        2. Update GitHub repository secret
        3. Deploy applications to pick up new value
        4. Verify all services are working

        ## 📊 Secret Inventory

        Check `secrets-inventory.json` for the complete list of managed secrets and their usage.

        ## 🆘 Troubleshooting

        - **Secret not found**: Ensure it's added to GitHub repository secrets
        - **Permission denied**: Check secret access permissions in repository settings
        - **Old secret still used**: Restart applications to pick up new values
        - **Hardcoded secret detected**: Run the auto-replace workflow

        ## 🔗 Related Files

        - `.env.production` - Production environment file (generated)
        - `.env.development.template` - Development template
        - `webapi/appsettings.template.json` - Backend configuration template  
        - `docker-compose.template.yml` - Docker configuration template
        - `secrets-inventory.json` - Complete secret inventory
        EOF

        echo "✅ Generated SECRET_MANAGEMENT.md"

    - name: 📤 Upload configuration templates
      uses: actions/upload-artifact@v3
      with:
        name: configuration-templates
        path: |
          webapi/appsettings.template.json
          docker-compose.template.yml
          SECRET_MANAGEMENT.md
        retention-days: 30

  # Job 5: Security report
  security-report:
    name: 📊 Security Report
    runs-on: ubuntu-latest
    needs: [secret-scan, sync-secrets]
    if: always()
    
    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4

    - name: 📊 Generate security report
      run: |
        cat > security-report.md << EOF
        # 🔐 Security Report - $(date)

        ## 📋 Summary
        
        - **Repository**: ${{ github.repository }}
        - **Branch**: ${{ github.ref }}
        - **Commit**: ${{ github.sha }}
        - **Workflow**: ${{ github.workflow }}
        - **Run ID**: ${{ github.run_id }}

        ## 🔍 Secret Scan Results
        
        - **Secrets Found**: ${{ needs.secret-scan.outputs.secrets-found }}
        - **Action Taken**: ${{ needs.secret-scan.outputs.secrets-found == 'true' && 'Auto-replacement triggered' || 'No action needed' }}

        ## 🛡️ Security Status

        ✅ **GitHub Secrets**: Configured and managed  
        ✅ **Automated Scanning**: Daily scans enabled  
        ✅ **Auto-Replacement**: Available on-demand  
        ✅ **Environment Templates**: Generated and updated  

        ## 📈 Recommendations

        1. Review and rotate secrets quarterly
        2. Monitor security alerts and dependabot updates  
        3. Keep secret inventory up to date
        4. Use different secrets for different environments
        5. Enable branch protection rules for main branch

        ## 🔗 Resources

        - [GitHub Secrets Documentation](https://docs.github.com/en/actions/security-guides/encrypted-secrets)
        - [Secret Management Guide](./SECRET_MANAGEMENT.md)
        - [Security Best Practices](https://docs.github.com/en/actions/security-guides)

        ---
        *This report was generated automatically by GitHub Actions*
        EOF

    - name: 📤 Upload security report
      uses: actions/upload-artifact@v3
      with:
        name: security-report
        path: security-report.md
        retention-days: 30

    - name: 💬 Comment on PR (if applicable)
      if: github.event_name == 'pull_request' && needs.secret-scan.outputs.secrets-found == 'true'
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: '🔐 **Secret Management Alert**\n\nHardcoded secrets were detected in this PR. Please use GitHub secrets instead of hardcoding API keys and passwords.\n\n📋 **Next Steps:**\n1. Add secrets to GitHub repository secrets\n2. Replace hardcoded values with `${SECRET_NAME}` references\n3. Run the secret replacement workflow if needed\n\nSee the [Secret Management Guide](./SECRET_MANAGEMENT.md) for details.'
          })